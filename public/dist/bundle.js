/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/components/Hydro_Estimator_Rainfall/HourlyRainfall.js":
/*!*******************************************************************!*\
  !*** ./src/components/Hydro_Estimator_Rainfall/HourlyRainfall.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupHourlyRainfall: () => (/* binding */ setupHourlyRainfall)\n/* harmony export */ });\n/* harmony import */ var _utils_notifications_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/notifications.js */ \"./src/utils/notifications.js\");\n/* harmony import */ var _utils_formatTimestamp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/formatTimestamp.js */ \"./src/utils/formatTimestamp.js\");\n/* harmony import */ var _apiManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./apiManager.js */ \"./src/components/Hydro_Estimator_Rainfall/apiManager.js\");\n/* harmony import */ var _animationManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./animationManager.js */ \"./src/components/Hydro_Estimator_Rainfall/animationManager.js\");\n/* harmony import */ var _refreshScheduler_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./refreshScheduler.js */ \"./src/components/Hydro_Estimator_Rainfall/refreshScheduler.js\");\n/* harmony import */ var _rainFallControl_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rainFallControl.js */ \"./src/components/Hydro_Estimator_Rainfall/rainFallControl.js\");\n/**\r\n * @file src/components/Hydro_Estimator_Rainfall/HourlyRainfall.js\r\n * @description Módulo para gestão de camadas de precipitação horária no mapa Leaflet.\r\n * @module HourlyRainfall\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction setupHourlyRainfall(map) {\r\n\r\n    const productID = 'NESDIS-GHE-HourlyRainfall';\r\n    let timestamps = [];\r\n\r\n    // Aqui criamos o controle e obtemos sua instância\r\n    const rainfallControl = (0,_rainFallControl_js__WEBPACK_IMPORTED_MODULE_5__.addRainfallControl)(map, {\r\n        onPlay: () => {\r\n          console.debug('Callback onPlay: retome a animação de chuva.');\r\n          if (map.rainfallAnimationController) {\r\n              map.rainfallAnimationController.resume();\r\n          }\r\n        },\r\n        onPause: () => {\r\n          console.debug('Callback onPause: pause a animação de chuva.');\r\n          if (map.rainfallAnimationController) {\r\n              map.rainfallAnimationController.pause();\r\n          }\r\n        }\r\n     });\r\n    // Defina aqui as fronteiras para o estado de Mato Grosso (ou outra região)\r\n    const boundsMT = [\r\n        [-18.1835, -63.0000],\r\n        [-7.9869, -50.2244]\r\n    ];\r\n\r\n    // Instancia nosso gerenciador de animação\r\n    const { startAnimation } = (0,_animationManager_js__WEBPACK_IMPORTED_MODULE_3__.createAnimationManager)(map, productID, boundsMT, rainfallControl);\r\n\r\n    // Callbacks para o agendamento de atualização\r\n    function handleRefreshSuccess(newTimestamps) {\r\n        timestamps = newTimestamps;\r\n        console.log('Timestamps atualizados:', timestamps.map(_utils_formatTimestamp_js__WEBPACK_IMPORTED_MODULE_1__.formatTimestamp));\r\n        // Agenda novamente\r\n        (0,_refreshScheduler_js__WEBPACK_IMPORTED_MODULE_4__.scheduleRefresh)({\r\n            timestamps,\r\n            productID,\r\n            onRefreshSuccess: handleRefreshSuccess,\r\n            onRefreshError: handleRefreshError\r\n        });\r\n    }\r\n\r\n    function handleRefreshError(error) {\r\n        console.error('Erro ao atualizar timestamps:', error.message);\r\n        // Mesmo em caso de erro, podemos agendar novamente para tentar no futuro\r\n        (0,_refreshScheduler_js__WEBPACK_IMPORTED_MODULE_4__.scheduleRefresh)({\r\n            timestamps,\r\n            productID,\r\n            onRefreshSuccess: handleRefreshSuccess,\r\n            onRefreshError: handleRefreshError\r\n        });\r\n    }\r\n\r\n    // Busca inicial dos timestamps e inicia a animação\r\n    (0,_apiManager_js__WEBPACK_IMPORTED_MODULE_2__.fetchTimestamps)(productID)\r\n        .then(data => {\r\n            timestamps = data;\r\n            console.log('Tempos carregados:', timestamps.map(_utils_formatTimestamp_js__WEBPACK_IMPORTED_MODULE_1__.formatTimestamp));\r\n            if (timestamps.length > 0) {\r\n                // Inicia a animação e armazena o controller no objeto do mapa\r\n                const animationController = startAnimation(timestamps);\r\n                map.rainfallAnimationController = animationController;\r\n                (0,_refreshScheduler_js__WEBPACK_IMPORTED_MODULE_4__.scheduleRefresh)({\r\n                    timestamps,\r\n                    productID,\r\n                    onRefreshSuccess: handleRefreshSuccess,\r\n                    onRefreshError: handleRefreshError\r\n                });\r\n            } else {\r\n                console.warn('Nenhum timestamp válido dentro do intervalo de 2 horas.');\r\n                (0,_utils_notifications_js__WEBPACK_IMPORTED_MODULE_0__.showError)('Nenhum dado disponível nas últimas 2 horas.');\r\n            }\r\n        })\r\n        .catch(error => {\r\n            console.error('Erro ao carregar tempos:', error.message);\r\n            (0,_utils_notifications_js__WEBPACK_IMPORTED_MODULE_0__.showError)('Falha ao carregar tempos do RealEarth. Verifique a conexão ou a API.');\r\n        });\r\n}\r\n\n\n//# sourceURL=webpack://ana_map/./src/components/Hydro_Estimator_Rainfall/HourlyRainfall.js?");

/***/ }),

/***/ "./src/components/Hydro_Estimator_Rainfall/animationManager.js":
/*!*********************************************************************!*\
  !*** ./src/components/Hydro_Estimator_Rainfall/animationManager.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAnimationManager: () => (/* binding */ createAnimationManager)\n/* harmony export */ });\n/* harmony import */ var _utils_formatTimestamp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatTimestamp.js */ \"./src/utils/formatTimestamp.js\");\n/* harmony import */ var _utils_notifications_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/notifications.js */ \"./src/utils/notifications.js\");\n/**\r\n * @file src/components/Hydro_Estimator_Rainfall/animationManager.js\r\n * @description Módulo responsável pela lógica de animação das camadas de chuva (precipitação horária).\r\n */\r\n\r\n\r\n\r\n/**\r\n * Cria um gerenciador de animação para uma camada específica.\r\n * @param {Object} map - Instância do mapa Leaflet.\r\n * @param {string} productID - ID do produto a ser carregado.\r\n * @param {Array} boundsMT - Limites (bounds) para visualização no mapa [sul-oeste, norte-leste].\r\n *  * @param {Object} [rainfallControl] - (Opcional) Referência ao controle de chuva, para exibir data/hora do frame.\r\n * @returns {Object} - Retorna métodos para iniciar e atualizar a animação.\r\n */\r\n\r\nfunction createAnimationManager(map, productID, boundsMT, rainfallControl = null) {\r\n    let overlayLayer = null;\r\n    let nextOverlayLayer = null;\r\n    let animationFrameId = null;\r\n\r\n    /**\r\n     * Função que cria e pré-carrega o novo overlay (o frame atual da animação).\r\n     * @param {number} time - Timestamp para o qual o overlay deve ser carregado.\r\n     */\r\n    async function updateOverlay(time) {\r\n        \r\n        const tileUrl = `http://localhost:3000/proxy/image?products=${productID}&time=${time}&x={x}&y={y}&z={z}`;\r\n\r\n        // Cria a camada de tiles usando a URL específica para cada frame (time)\r\n        nextOverlayLayer = L.tileLayer(tileUrl, {\r\n            // Define a opacidade inicial como 0 (para permitir o fade-in)\r\n            opacity: 0,\r\n            // Limita a exibição dos tiles à região definida em boundsMT\r\n            bounds: boundsMT,\r\n            // Define o tamanho de cada tile (256 pixels por 256 pixels)\r\n            tileSize: 256,\r\n            // Determina o maior nível de zoom nativo das imagens (acima disso, o Leaflet fará overzoom)\r\n            maxNativeZoom: 7,\r\n            // Define o zoom máximo permitido para o mapa (pode ampliar além do nativo)\r\n            maxZoom: 12,\r\n        }).addTo(map); // Adiciona a nova camada de tiles ao mapa\r\n\r\n        // Aguarda o carregamento completo dos tiles\r\n        await new Promise(resolve => {\r\n            nextOverlayLayer.once('load', resolve);\r\n        });\r\n\r\n        // Após os tiles estarem carregados, atualiza o display de data/hora\r\n        const formatted = (0,_utils_formatTimestamp_js__WEBPACK_IMPORTED_MODULE_0__.formatTimestamp)(time);\r\n        console.log('(UTC+0):', formatted);\r\n        if (rainfallControl && typeof rainfallControl.updateDateTime === 'function') {\r\n            rainfallControl.updateDateTime(formatted);\r\n        }\r\n\r\n        smoothTransition();\r\n    }\r\n\r\n    /**\r\n     * Faz a transição suave (fade) entre o overlay atual e o próximo.\r\n     */\r\n    function smoothTransition() {\r\n        const fadeOutDuration = 3; // ms\r\n        const fadeInDuration = 2;  // ms\r\n        let start = null;\r\n\r\n        // 1. Fade-out do overlay atual\r\n        function fadeOut(timestamp) {\r\n            if (!start) start = timestamp;\r\n            let progress = timestamp - start;\r\n            let t = Math.min(progress / fadeOutDuration, 1);\r\n\r\n            if (overlayLayer) {\r\n                overlayLayer.setOpacity(1 - t);\r\n            }\r\n\r\n            if (progress < fadeOutDuration) {\r\n                animationFrameId = requestAnimationFrame(fadeOut);\r\n            } else {\r\n                // Remover o overlay anterior\r\n                if (overlayLayer) {\r\n                    map.removeLayer(overlayLayer);\r\n                }\r\n                overlayLayer = null;\r\n                // Reinicia o \"relógio\" para o fade-in\r\n                start = null;\r\n                animationFrameId = requestAnimationFrame(fadeIn);\r\n            }\r\n        }\r\n\r\n        // 2. Fade-in do novo overlay\r\n        function fadeIn(timestamp) {\r\n            if (!start) start = timestamp;\r\n            let progress = timestamp - start;\r\n            let t = Math.min(progress / fadeInDuration, 1);\r\n\r\n            if (nextOverlayLayer) {\r\n                nextOverlayLayer.setOpacity(t);\r\n            }\r\n\r\n            if (progress < fadeInDuration) {\r\n                animationFrameId = requestAnimationFrame(fadeIn);\r\n            } else {\r\n                // Concluído o fade-in, define o novo overlay como principal\r\n                overlayLayer = nextOverlayLayer;\r\n                if (overlayLayer) {\r\n                    overlayLayer.bringToFront();\r\n                }\r\n                nextOverlayLayer = null;\r\n            }\r\n        }\r\n\r\n        // Cancela animação em progresso (se existir)\r\n        if (animationFrameId) {\r\n            cancelAnimationFrame(animationFrameId);\r\n        }\r\n\r\n        // Inicia a animação com fade-out do overlay atual\r\n        animationFrameId = requestAnimationFrame(fadeOut);\r\n    }\r\n\r\n    /**\r\n    * Inicia o loop de animação, percorrendo todos os timestamps disponíveis.\r\n    * @param {number[]} timestamps - Lista de timestamps retornados pela API.\r\n    * @returns {Object} - Um controller com métodos pause() e resume() para controlar a animação.\r\n    */\r\n    function startAnimation(timestamps) {\r\n        if (!timestamps || timestamps.length === 0) {\r\n            console.warn('Nenhum frame disponível para animação.');\r\n            (0,_utils_notifications_js__WEBPACK_IMPORTED_MODULE_1__.showError)('Nenhum dado disponível para animação.');\r\n            return;\r\n        }\r\n\r\n        let currentFrame = 0;\r\n        let paused = false;\r\n        let timeoutId = null;\r\n\r\n        function nextFrame() {\r\n            if (paused) return; // Se estiver pausado, não progride para o próximo frame.\r\n\r\n            if (currentFrame >= timestamps.length) {\r\n                currentFrame = 0;\r\n            }\r\n            updateOverlay(timestamps[currentFrame]);\r\n\r\n            // Define o delay para cada frame (ajuste conforme necessário)\r\n            const isLastFrame = (currentFrame === timestamps.length - 1);\r\n            const delay = isLastFrame ? 15000 : 3000;\r\n            currentFrame++;\r\n            timeoutId = setTimeout(nextFrame, delay);\r\n        }\r\n\r\n        nextFrame();\r\n\r\n        return {\r\n            pause: function () {\r\n                paused = true;\r\n                if (timeoutId) {\r\n                    clearTimeout(timeoutId);\r\n                    timeoutId = null;\r\n                }\r\n                console.debug('[AnimationManager] Animação pausada.');\r\n            },\r\n            resume: function () {\r\n                if (paused) {\r\n                    paused = false;\r\n                    console.debug('[AnimationManager] Animação retomada.');\r\n                    nextFrame();\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n\r\n    // Retorna as funções que o seu módulo principal precisará chamar\r\n    return {\r\n        startAnimation,\r\n        updateOverlay\r\n    };\r\n}\r\n\r\n\n\n//# sourceURL=webpack://ana_map/./src/components/Hydro_Estimator_Rainfall/animationManager.js?");

/***/ }),

/***/ "./src/components/Hydro_Estimator_Rainfall/apiManager.js":
/*!***************************************************************!*\
  !*** ./src/components/Hydro_Estimator_Rainfall/apiManager.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchTimestamps: () => (/* binding */ fetchTimestamps),\n/* harmony export */   refreshTimestamps: () => (/* binding */ refreshTimestamps)\n/* harmony export */ });\n/* harmony import */ var _utils_formatTimestamp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/formatTimestamp.js */ \"./src/utils/formatTimestamp.js\");\n/**\r\n * @file src/components/Hydro_Estimator_Rainfall/apiManager.js\r\n * @description Módulo para gerenciar requisições à API e manipulação de timestamps.\r\n */\r\n\r\n\r\n\r\n// Cache para requisições\r\nconst apiCache = {\r\n    data: null,\r\n    timestamp: null,\r\n    ttl: 1 * 60 * 60 * 1000 // 1 hora em milissegundos\r\n};\r\n\r\n// Filtra os timestamps para os últimos 2 horas (UTC)\r\nfunction filterTimestamps(data) {\r\n    const nowUTC = new Date(Date.now());\r\n    const twoHoursAgoUTC = new Date(nowUTC.getTime() - 2 * 60 * 60 * 1000);\r\n    return data.filter(timestamp => {\r\n        const tsDate = (0,_utils_formatTimestamp_js__WEBPACK_IMPORTED_MODULE_0__.convertTimestampToDate)(timestamp);\r\n        return tsDate >= twoHoursAgoUTC && tsDate <= nowUTC;\r\n    });\r\n}\r\n\r\n// Função para buscar os timestamps\r\nasync function fetchTimestamps(productID, useCache = true) {\r\n    try {\r\n        const now = Date.now();\r\n        if (useCache && apiCache.data && now - apiCache.timestamp < apiCache.ttl) {\r\n            console.log('Usando dados do cache...');\r\n            return filterTimestamps(apiCache.data);\r\n        }\r\n\r\n        const response = await fetch(`https://realearth.ssec.wisc.edu/api/times?products=${productID}`);\r\n        if (!response.ok) throw new Error(`Erro na requisição: ${response.statusText}`);\r\n        const data = await response.json();\r\n\r\n        if (!data || !data[productID] || !Array.isArray(data[productID]) || data[productID].length === 0) {\r\n            throw new Error('Nenhum tempo disponível na resposta da API.');\r\n        }\r\n\r\n        // Atualiza o cache\r\n        apiCache.data = data[productID];\r\n        apiCache.timestamp = now;\r\n\r\n        return filterTimestamps(apiCache.data);\r\n    } catch (error) {\r\n        console.error('Erro ao carregar tempos:', error.message);\r\n        throw error; // Propaga o erro para ser tratado no arquivo principal\r\n    }\r\n}\r\n\r\n// Função para atualizar os timestamps sem usar o cache\r\nasync function refreshTimestamps(productID) {\r\n    try {\r\n        const response = await fetch(`https://realearth.ssec.wisc.edu/api/times?products=${productID}`);\r\n        if (!response.ok) throw new Error(`Erro na requisição: ${response.statusText}`);\r\n        const data = await response.json();\r\n\r\n        if (!data || !data[productID] || !Array.isArray(data[productID]) || data[productID].length === 0) {\r\n            throw new Error('Nenhum tempo disponível na resposta da API.');\r\n        }\r\n\r\n        return filterTimestamps(data[productID]);\r\n    } catch (error) {\r\n        console.error('Erro ao atualizar timestamps:', error.message);\r\n        throw error; // Propaga o erro para ser tratado no arquivo principal\r\n    }\r\n}\n\n//# sourceURL=webpack://ana_map/./src/components/Hydro_Estimator_Rainfall/apiManager.js?");

/***/ }),

/***/ "./src/components/Hydro_Estimator_Rainfall/rainFallControl.js":
/*!********************************************************************!*\
  !*** ./src/components/Hydro_Estimator_Rainfall/rainFallControl.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addRainfallControl: () => (/* binding */ addRainfallControl)\n/* harmony export */ });\n/**\r\n * @file src/components/Hydro_Estimator_Rainfall/rainFallControl.js\r\n * @description Controle customizado para gerenciar a animação de chuva, incluindo Play/Pause e exibição de Data/Horário.\r\n */\r\n\r\n\r\nconst RainfallControl = L.Control.extend({\r\n    options: {\r\n        position: 'bottomleft', // Posiciona o controle no canto superior esquerdo\r\n        onPlay: null,        // Callback opcional para quando a animação for retomada\r\n        onPause: null        // Callback opcional para quando a animação for pausada\r\n    },\r\n\r\n    onAdd: function (map) {\r\n        console.debug('[RainfallControl] onAdd chamado.');\r\n\r\n        // Cria o container principal do controle, usando as classes para estilização via CSS\r\n        const container = L.DomUtil.create('div', 'leaflet-bar rainfall-control-container');\r\n\r\n        // Cria o botão de play/pause\r\n        const playPauseButton = L.DomUtil.create('a', 'rainfall-play-pause', container);\r\n        playPauseButton.href = '#';\r\n        playPauseButton.title = 'Play/Pause Animação de Chuva';\r\n        // Inicialmente, assumindo que a animação está rodando, exibimos o ícone de Pause ⏸\r\n        playPauseButton.innerHTML = '⏸';\r\n\r\n        // Cria a área de exibição de data/hora\r\n        const dateTimeDisplay = L.DomUtil.create('div', 'rainfall-date-time', container);\r\n        dateTimeDisplay.title = \"SEMPRE 4 horas adiantado em relação a Cuiabá\"; // Dica de ferramenta para informar a diferença de fuso horário\r\n\r\n        // Estado inicial da animação: em execução (playing)\r\n        this._animationPlaying = true;\r\n\r\n        // Método para atualizar a exibição de data/hora\r\n        this.updateDateTime = function (newDateTimeStr) {\r\n            dateTimeDisplay.innerHTML = newDateTimeStr + \" UTC+0\" ;\r\n        };\r\n\r\n        // Impede que cliques no controle propaguem para o mapa\r\n        L.DomEvent.disableClickPropagation(container);\r\n        L.DomEvent.on(playPauseButton, 'click', L.DomEvent.stop);\r\n        L.DomEvent.on(playPauseButton, 'click', L.DomEvent.preventDefault);\r\n\r\n        // Evento de clique no botão Play/Pause\r\n        L.DomEvent.on(playPauseButton, 'click', () => {\r\n            console.debug('[RainfallControl] Botão de play/pause clicado.');\r\n            \r\n            // Alterna o estado da animação\r\n            this._animationPlaying = !this._animationPlaying;\r\n            if (this._animationPlaying) {\r\n                // Se está voltando a tocar, exibimos o ícone de Pause\r\n                playPauseButton.innerHTML = '⏸';\r\n                console.debug('[RainfallControl] Animação retomada.');\r\n                if (typeof this.options.onPlay === 'function') {\r\n                    this.options.onPlay();\r\n                }\r\n            } else {\r\n                // Se foi pausado, exibimos o ícone de Play\r\n                playPauseButton.innerHTML = '▶';\r\n                console.debug('[RainfallControl] Animação pausada.');\r\n                if (typeof this.options.onPause === 'function') {\r\n                    this.options.onPause();\r\n                }\r\n            }\r\n        });\r\n\r\n        console.debug('[RainfallControl] Estado inicial definido como playing.');\r\n        return container;\r\n    }\r\n});\r\n\r\n/**\r\n * Função para adicionar o controle de chuva ao mapa.\r\n * Basta chamá-la passando a instância do mapa Leaflet.\r\n * @param {L.Map} map - Instância do mapa.\r\n * @param {Object} [options] - Opções adicionais, como callbacks onPlay e onPause.\r\n * @returns {L.Control} - Instância do controle adicionado.\r\n */\r\nfunction addRainfallControl(map, options = {}) {\r\n    console.debug('[RainfallControl] Adicionando controle ao mapa.');\r\n    const control = new RainfallControl(options);\r\n    control.addTo(map);\r\n    console.debug('[RainfallControl] Controle adicionado com sucesso na posição topleft.');\r\n    return control;\r\n}\r\n\n\n//# sourceURL=webpack://ana_map/./src/components/Hydro_Estimator_Rainfall/rainFallControl.js?");

/***/ }),

/***/ "./src/components/Hydro_Estimator_Rainfall/refreshScheduler.js":
/*!*********************************************************************!*\
  !*** ./src/components/Hydro_Estimator_Rainfall/refreshScheduler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scheduleRefresh: () => (/* binding */ scheduleRefresh)\n/* harmony export */ });\n/* harmony import */ var _apiManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./apiManager.js */ \"./src/components/Hydro_Estimator_Rainfall/apiManager.js\");\n/* harmony import */ var _utils_formatTimestamp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/formatTimestamp.js */ \"./src/utils/formatTimestamp.js\");\n/**\r\n * @file src/components/Hydro_Estimator_Rainfall/refreshScheduler.js\r\n * @description Módulo para agendar atualizações de timestamps a cada X minutos, com base no último timestamp disponível.\r\n */\r\n\r\n\r\n\r\n/**\r\n * Função para agendar a próxima atualização de timestamps.\r\n * @param {Object} params - Parâmetros necessários para agendar a atualização.\r\n * @param {number[]} params.timestamps - Lista atual de timestamps.\r\n * @param {string} params.productID - ID do produto no RealEarth.\r\n * @param {function} params.onRefreshSuccess - Callback chamado em caso de sucesso, recebe os novos timestamps.\r\n * @param {function} params.onRefreshError - Callback chamado em caso de erro, recebe o erro.\r\n * @param {number} [params.intervalMs=900000] - Intervalo base em milissegundos (15 min por padrão).\r\n * @param {number} [params.minDelay=60000] - Atraso mínimo em milissegundos (1 min por padrão).\r\n */\r\nfunction scheduleRefresh({\r\n  timestamps,\r\n  productID,\r\n  onRefreshSuccess,\r\n  onRefreshError,\r\n  intervalMs = 15 * 60 * 1000, // 15 minutos\r\n  minDelay = 60 * 1000        // 1 minuto\r\n}) {\r\n  // Caso não haja timestamps, aguarde 'intervalMs' e tente novamente\r\n  if (timestamps.length === 0) {\r\n    setTimeout(async () => {\r\n      try {\r\n        const newTimestamps = await (0,_apiManager_js__WEBPACK_IMPORTED_MODULE_0__.refreshTimestamps)(productID);\r\n        onRefreshSuccess(newTimestamps);\r\n      } catch (error) {\r\n        onRefreshError(error);\r\n      }\r\n    }, intervalMs);\r\n    return;\r\n  }\r\n\r\n  // Pega o último timestamp e calcula o horário do próximo update\r\n  const lastTs = timestamps[timestamps.length - 1];\r\n  const lastDate = (0,_utils_formatTimestamp_js__WEBPACK_IMPORTED_MODULE_1__.convertTimestampToDate)(lastTs);\r\n  const nextUpdateTime = lastDate.getTime() + intervalMs;\r\n  const now = Date.now();\r\n  let delay = nextUpdateTime - now;\r\n\r\n  // Garante um atraso mínimo\r\n  if (delay < minDelay) {\r\n    delay = minDelay;\r\n  }\r\n\r\n  console.log(\r\n    `Agendando próxima atualização em ${Math.round(delay / 1000)} segundos ` +\r\n    `(baseado no último timestamp: ${(0,_utils_formatTimestamp_js__WEBPACK_IMPORTED_MODULE_1__.formatTimestamp)(lastTs)})`\r\n  );\r\n\r\n  setTimeout(async () => {\r\n    try {\r\n      const newTimestamps = await (0,_apiManager_js__WEBPACK_IMPORTED_MODULE_0__.refreshTimestamps)(productID);\r\n      onRefreshSuccess(newTimestamps);\r\n    } catch (error) {\r\n      onRefreshError(error);\r\n    }\r\n  }, delay);\r\n}\r\n\n\n//# sourceURL=webpack://ana_map/./src/components/Hydro_Estimator_Rainfall/refreshScheduler.js?");

/***/ }),

/***/ "./src/components/ana/markerStyle.js":
/*!*******************************************!*\
  !*** ./src/components/ana/markerStyle.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSquareMarker: () => (/* binding */ createSquareMarker)\n/* harmony export */ });\n// src/components/ana/markerStyle.js\r\n\r\n/**\r\n * Função para criar um marcador quadrado com estilo personalizado\r\n * @param {String} color - Cor de fundo do marcador\r\n * @param {String} text - Texto a ser exibido no marcador\r\n * @returns {L.DivIcon} - Ícone de marcador personalizado\r\n */\r\nconst createSquareMarker = (color, text) => {\r\n    return L.divIcon({\r\n        className: 'square-marker',\r\n        html: `\r\n            <div class=\"marker-content\" style=\"background-color: ${color};\">\r\n                <span>${text}</span>\r\n            </div>\r\n        `,\r\n        iconSize: [30, 30],  // Tamanho do marcador quadrado\r\n        iconAnchor: [15, 15], // Ancoragem para o centro do marcador\r\n        popupAnchor: [0, -15] // Localização da popup em relação ao marcador\r\n    });\r\n};\r\n\n\n//# sourceURL=webpack://ana_map/./src/components/ana/markerStyle.js?");

/***/ }),

/***/ "./src/components/ana/stationsMarkers.js":
/*!***********************************************!*\
  !*** ./src/components/ana/stationsMarkers.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StationMarkers: () => (/* binding */ StationMarkers)\n/* harmony export */ });\n/* harmony import */ var _markerStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./markerStyle.js */ \"./src/components/ana/markerStyle.js\");\n// file: src\\components\\ana\\stationsMarkers.js\r\n\r\n\r\n// Constantes para valores mágicos\r\nconst DEFAULT_CONFIG = {\r\n    MARKER_COLOR: '#8c8eb6',\r\n    MARKER_TEXT_LENGTH: 3,\r\n    INVALID_VALUE: 'N/A',\r\n    DATA_SOURCE: '/data/inventario_estacoes.json',\r\n    TELEMETRIC_DATE: '2025-01-31' // Data fixa conforme solicitado\r\n};\r\n\r\n// Módulo de utilitários\r\nconst DataFormatter = {\r\n    formatArea: (value) =>\r\n        value && !isNaN(value)\r\n            ? `${parseFloat(value).toLocaleString()} km²`\r\n            : DEFAULT_CONFIG.INVALID_VALUE,\r\n\r\n    formatSubBasin: (value) =>\r\n        value\r\n            ? value.replace(/,+/g, ', ').trim()\r\n            : DEFAULT_CONFIG.INVALID_VALUE,\r\n\r\n    formatCoordinate: (value) =>\r\n        value || DEFAULT_CONFIG.INVALID_VALUE,\r\n\r\n    formatDate: (value) =>\r\n        value ? new Date(value).toLocaleDateString('pt-BR') : DEFAULT_CONFIG.INVALID_VALUE,\r\n\r\n    formatTime: (value) =>\r\n        value ? new Date(value).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : DEFAULT_CONFIG.INVALID_VALUE\r\n};\r\n\r\n// Módulo principal\r\nconst StationMarkers = (() => {\r\n    let markerLayer = L.layerGroup();\r\n    let currentMap = null;\r\n\r\n    const fetchTelemetricData = async (stationCode) => {\r\n        try {\r\n            const [year, month, day] = DEFAULT_CONFIG.TELEMETRIC_DATE.split('-');\r\n            const url = `/data/${year}/${month}/${DEFAULT_CONFIG.TELEMETRIC_DATE}/codigoestacao_${stationCode}.json`;\r\n\r\n            const response = await fetch(url);\r\n            if (!response.ok) return null;\r\n            return await response.json();\r\n        } catch (error) {\r\n            console.error('Erro ao buscar dados telemetricos:', error);\r\n            return null;\r\n        }\r\n    };\r\n\r\n    const createTelemetricContent = (data) => {\r\n        if (!data?.dados?.length) return '';\r\n\r\n        const latestEntry = data.dados.reduce((latest, current) =>\r\n            new Date(current.Data_Hora_Medicao) > new Date(latest.Data_Hora_Medicao) ? current : latest\r\n        );\r\n\r\n        return `\r\n      <div class=\"telemetric-section\">\r\n        <h4>Dados Telemetricos (${data.data})</h4>\r\n        <strong>Última atualização:</strong> ${DataFormatter.formatDateTime(latestEntry.Data_Atualizacao)}<br>\r\n        <strong>Cota:</strong> ${latestEntry.Cota_Adotada || DEFAULT_CONFIG.INVALID_VALUE}<br>\r\n        <strong>Vazão:</strong> ${latestEntry.Vazao_Adotada || DEFAULT_CONFIG.INVALID_VALUE}<br>\r\n        <strong>Chuva:</strong> ${latestEntry.Chuva_Adotada || DEFAULT_CONFIG.INVALID_VALUE}\r\n      </div>\r\n    `;\r\n    };\r\n\r\n    const createPopupContent = async (station) => {\r\n        let baseContent = `\r\n            <div class=\"popup-container\">\r\n                <div class=\"popup-header\">\r\n                    <h4>Informações da Estação</h4>\r\n                    <span class=\"toggle-icon\">▷</span>\r\n                </div>\r\n                <div class=\"popup-grid expandable collapsed\">\r\n                <div class=\"data-item\">\r\n                    <span class=\"data-label\">Estação</span>\r\n                    <span class=\"data-value\">${station.Estacao_Nome || DEFAULT_CONFIG.INVALID_VALUE}</span>\r\n                </div>\r\n                \r\n                <div class=\"data-item\">\r\n                    <span class=\"data-label\">Código</span>\r\n                    <span class=\"data-value\">${station.codigoestacao || DEFAULT_CONFIG.INVALID_VALUE}</span>\r\n                </div>\r\n\r\n                <div class=\"data-item\">\r\n                    <span class=\"data-label\">Rio</span>\r\n                    <span class=\"data-value\">${station.Rio_Nome || DEFAULT_CONFIG.INVALID_VALUE}</span>\r\n                </div>\r\n\r\n                <div class=\"data-item\">\r\n                    <span class=\"data-label\">Município</span>\r\n                    <span class=\"data-value\">${station.Municipio_Nome || DEFAULT_CONFIG.INVALID_VALUE}</span>\r\n                </div>\r\n\r\n                <div class=\"data-item\">\r\n                    <span class=\"data-label\">Altura</span>\r\n                    <span class=\"data-value\">${station.Altitude ? `${station.Altitude} m` : DEFAULT_CONFIG.INVALID_VALUE}</span>\r\n                </div>\r\n\r\n                <div class=\"data-item\">\r\n                    <span class=\"data-label\">Bacia</span>\r\n                    <span class=\"data-value\">${station.Bacia_Nome || DEFAULT_CONFIG.INVALID_VALUE}</span>\r\n                </div>\r\n\r\n                <div class=\"data-item\">\r\n                    <span class=\"data-label\">Área Drenagem</span>\r\n                    <span class=\"data-value\">${DataFormatter.formatArea(station.Area_Drenagem)}</span>\r\n                </div>\r\n\r\n                <div class=\"coordinate-section\">\r\n                    <div class=\"data-item\">\r\n                        <span class=\"data-label\">Latitude</span>\r\n                        <span class=\"data-value\">${DataFormatter.formatCoordinate(station.Latitude)}</span>\r\n                    </div>\r\n                    <div class=\"data-item\">\r\n                        <span class=\"data-label\">Longitude</span>\r\n                        <span class=\"data-value\">${DataFormatter.formatCoordinate(station.Longitude)}</span>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        `;\r\n\r\n        try {\r\n            const telemetricData = await fetchTelemetricData(station.codigoestacao);\r\n            if (telemetricData?.dados?.length) {\r\n                const latestEntry = telemetricData.dados.reduce((latest, current) =>\r\n                    new Date(current.Data_Hora_Medicao) > new Date(latest.Data_Hora_Medicao) ? current : latest\r\n                );\r\n\r\n                baseContent += `\r\n                    <div class=\"telemetric-section\">\r\n                        <div class=\"telemetric-header\">\r\n                            <h4 class=\"telemetric-title\">Dados Telemetricos (${DataFormatter.formatDate(latestEntry.Data_Hora_Medicao)})</h4>\r\n                            <div class=\"data-label\">\r\n                                Medição: ${DataFormatter.formatTime(latestEntry.Data_Hora_Medicao)}<br>\r\n                                Atualização: ${DataFormatter.formatTime(latestEntry.Data_Atualizacao)}\r\n                            </div>\r\n                        </div>\r\n                        \r\n                        <div class=\"telemetric-card\">\r\n                            <span class=\"data-label\">Cota</span>\r\n                            <span class=\"data-value\">${latestEntry.Cota_Adotada || DEFAULT_CONFIG.INVALID_VALUE}</span>\r\n                            ${latestEntry.Cota_Adotada ? '<span class=\"data-unit\">m</span>' : ''}\r\n                        </div>\r\n\r\n                        <div class=\"telemetric-card\">\r\n                            <span class=\"data-label\">Vazão</span>\r\n                            <span class=\"data-value\">${latestEntry.Vazao_Adotada || DEFAULT_CONFIG.INVALID_VALUE}</span>\r\n                            ${latestEntry.Vazao_Adotada ? '<span class=\"data-unit\">m³/s</span>' : ''}\r\n                        </div>\r\n\r\n                        <div class=\"telemetric-card\">\r\n                            <span class=\"data-label\">Chuva</span>\r\n                            <span class=\"data-value\">${latestEntry.Chuva_Adotada || DEFAULT_CONFIG.INVALID_VALUE}</span>\r\n                            ${latestEntry.Chuva_Adotada ? '<span class=\"data-unit\">mm</span>' : ''}\r\n                        </div>\r\n                    </div>\r\n                `;\r\n            }\r\n        } catch (error) {\r\n            baseContent += `\r\n            <div class=\"telemetric-error\">\r\n                ⚠️ Não foi possível carregar os dados telemetricos em tempo real\r\n            </div>\r\n        `;\r\n        }\r\n\r\n        baseContent += '</div>'; // Fecha popup-grid\r\n        return baseContent;\r\n    };\r\n\r\n    // Modifique a função createMarker desta forma:\r\n    const createMarker = (station) => {\r\n        const marker = L.marker([station.Latitude, station.Longitude], {\r\n            icon: (0,_markerStyle_js__WEBPACK_IMPORTED_MODULE_0__.createSquareMarker)(\r\n                DEFAULT_CONFIG.MARKER_COLOR,\r\n                station.Estacao_Nome.substring(0, DEFAULT_CONFIG.MARKER_TEXT_LENGTH)\r\n            )\r\n        });\r\n\r\n        marker.stationData = station;\r\n        marker.bindPopup(() => {\r\n            const popup = L.DomUtil.create('div');\r\n            createPopupContent(station).then(content => {\r\n                popup.innerHTML = content;\r\n\r\n                // Adicione este bloco dentro do then()\r\n                popup.querySelectorAll('.popup-header').forEach(header => {\r\n                    header.addEventListener('click', () => {\r\n                        const content = header.nextElementSibling;\r\n                        const icon = header.querySelector('.toggle-icon');\r\n\r\n                        content.classList.toggle('collapsed');\r\n                        icon.classList.toggle('rotated');\r\n                    });\r\n                });\r\n            });\r\n            return popup;\r\n        });\r\n\r\n        return marker;\r\n    };\r\n\r\n    const updateVisibility = () => {\r\n        const bounds = currentMap.getBounds();\r\n        markerLayer.eachLayer(marker => {\r\n            bounds.contains(marker.getLatLng())\r\n                ? marker.addTo(currentMap)\r\n                : marker.remove();\r\n        });\r\n    };\r\n\r\n    return {\r\n        initialize: (map) => {\r\n            currentMap = map;\r\n            markerLayer.addTo(map);\r\n            map.on('moveend zoomend', updateVisibility);\r\n        },\r\n\r\n        load: async () => {\r\n            try {\r\n                const response = await fetch(DEFAULT_CONFIG.DATA_SOURCE);\r\n                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\r\n\r\n                const stations = await response.json();\r\n                stations.forEach(station => markerLayer.addLayer(createMarker(station)));\r\n                updateVisibility();\r\n            } catch (error) {\r\n                console.error('Failed to load stations:', error);\r\n                throw error;\r\n            }\r\n        },\r\n\r\n        clear: () => {\r\n            markerLayer.clearLayers();\r\n            currentMap.off('moveend zoomend', updateVisibility);\r\n        }\r\n    };\r\n})();\r\n\r\n\n\n//# sourceURL=webpack://ana_map/./src/components/ana/stationsMarkers.js?");

/***/ }),

/***/ "./src/components/fileHandler.js":
/*!***************************************!*\
  !*** ./src/components/fileHandler.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   importFiles: () => (/* binding */ importFiles),\n/* harmony export */   removeUploadedFile: () => (/* binding */ removeUploadedFile),\n/* harmony export */   renderFileOnMap: () => (/* binding */ renderFileOnMap)\n/* harmony export */ });\n/**\r\n * Módulo de importação e visualização de arquivos no mapa (Refatorado).\r\n * @module fileHandler\r\n */\r\n\r\n// Constantes para ícones e caminhos\r\nconst ICON_BASE_PATH = 'assets/icons/';\r\nconst FILE_TYPE_ICONS = {\r\n    geojson: 'geojson.png',\r\n    json: 'json.png',\r\n    kml: 'kml.png',\r\n    gpx: 'gpx.png',\r\n    default: 'file.png'\r\n};\r\n\r\n/**\r\n * @typedef {Object} FileImportConfig\r\n * @property {FileList} files - Lista de arquivos selecionados pelo usuário.\r\n * @property {HTMLElement} fileListElement - Elemento do DOM onde serão exibidos os arquivos e barras de progresso.\r\n * @property {HTMLButtonElement} confirmButton - Botão de confirmação de upload.\r\n * @property {File[]} uploadedFiles - Array com os arquivos já carregados em memória.\r\n * @property {boolean} [skipDuplicates] - Se true, arquivos com nome+size repetidos serão ignorados. Default: true.\r\n */\r\n\r\n/**\r\n * Importa arquivos do sistema e exibe-os em uma lista com barra de progresso.\r\n * Evita inserir duplicados se 'skipDuplicates' estiver true.\r\n * \r\n * @param {FileImportConfig} config - Objeto de configuração com arquivos, elementos do DOM e lista de arquivos.\r\n */\r\nfunction importFiles(config) {\r\n    const {\r\n        files,\r\n        fileListElement,\r\n        confirmButton,\r\n        uploadedFiles,\r\n        skipDuplicates = true\r\n    } = config;\r\n\r\n    if (!files || files.length === 0) {\r\n        console.log('Nenhum arquivo selecionado ou importação cancelada.');\r\n        return;\r\n    }\r\n\r\n    Array.from(files).forEach(file => {\r\n        if (skipDuplicates && isDuplicate(file, uploadedFiles)) {\r\n            console.warn(`O arquivo ${file.name} já foi importado. Ignorando duplicata.`);\r\n            return;\r\n        }\r\n\r\n        const fileItemElement = createFileItemElement(file, confirmButton, uploadedFiles);\r\n        fileListElement.appendChild(fileItemElement);\r\n\r\n        const reader = new FileReader();\r\n        const progressBar = fileItemElement.querySelector('.file-progress');\r\n\r\n        setupFileReaderEvents(reader, file, progressBar, confirmButton, uploadedFiles);\r\n        reader.readAsText(file);\r\n    });\r\n}\r\n\r\n/**\r\n * Verifica se o arquivo já existe na lista (com base em nome e tamanho).\r\n * @param {File} newFile - Arquivo que queremos inserir.\r\n * @param {File[]} uploadedFiles - Lista de arquivos já carregados.\r\n * @returns {boolean} - True se é duplicado, false caso contrário.\r\n */\r\nfunction isDuplicate(newFile, uploadedFiles) {\r\n    return uploadedFiles.some(file =>\r\n        file.name === newFile.name &&\r\n        file.size === newFile.size\r\n    );\r\n}\r\n\r\n/**\r\n * Cria o elemento de lista (DOM) para um arquivo, incluindo nome, progresso e botão de exclusão.\r\n * @param {File} file - Arquivo a ser exibido.\r\n * @param {HTMLButtonElement} confirmButton - Botão de confirmação de upload.\r\n * @param {File[]} uploadedFiles - Lista de arquivos já armazenados.\r\n * @returns {HTMLDivElement} - Elemento <div> que representa o item do arquivo na lista.\r\n */\r\nfunction createFileItemElement(file, confirmButton, uploadedFiles) {\r\n    const fileItem = document.createElement('div');\r\n    fileItem.classList.add('file-item');\r\n\r\n    fileItem.innerHTML = `\r\n      <span class=\"file-name\">${file.name}</span>\r\n      <progress class=\"file-progress\" value=\"0\" max=\"100\"></progress>\r\n      <span class=\"file-size\">${formatFileSize(file.size)}</span>\r\n      <button class=\"delete-file-btn\">Excluir</button>\r\n    `;\r\n\r\n    const deleteButton = fileItem.querySelector('.delete-file-btn');\r\n    deleteButton.addEventListener('click', () => {\r\n        removeUploadedFile(fileItem, file, uploadedFiles, confirmButton);\r\n    });\r\n\r\n    return fileItem;\r\n}\r\n\r\n/**\r\n * Configura os eventos do FileReader para exibir progresso de leitura e armazenar o arquivo quando finalizado.\r\n * @param {FileReader} reader - Instância de FileReader para ler o arquivo.\r\n * @param {File} file - Arquivo sendo lido.\r\n * @param {HTMLProgressElement} progressBar - Barra de progresso associada ao arquivo.\r\n * @param {HTMLButtonElement} confirmButton - Botão de confirmação.\r\n * @param {File[]} uploadedFiles - Lista de arquivos carregados.\r\n */\r\nfunction setupFileReaderEvents(reader, file, progressBar, confirmButton, uploadedFiles) {\r\n    reader.onerror = () => {\r\n        console.error(`Erro ao ler o arquivo: ${file.name}`);\r\n        alert('Erro ao ler o arquivo. Tente novamente.');\r\n    };\r\n\r\n    reader.onloadstart = () => {\r\n        progressBar.value = 0;\r\n    };\r\n\r\n    reader.onprogress = event => {\r\n        if (event.lengthComputable) {\r\n            const percentage = (event.loaded / event.total) * 100;\r\n            progressBar.value = percentage;\r\n        }\r\n    };\r\n\r\n    reader.onload = () => {\r\n        uploadedFiles.push(file);\r\n        confirmButton.style.display = 'block';\r\n    };\r\n}\r\n\r\n/**\r\n * Formata o tamanho do arquivo em KB com 2 casas decimais.\r\n * @param {number} size - Tamanho do arquivo em bytes.\r\n * @returns {string} - Tamanho formatado em KB.\r\n */\r\nfunction formatFileSize(size) {\r\n    const sizeInKB = size / 1024;\r\n    return `${sizeInKB.toFixed(2)} KB`;\r\n}\r\n\r\n/**\r\n * Remove o item do arquivo exibido na lista, retira-o do array de arquivos e\r\n * ajusta a visibilidade do botão \"OK\" caso não haja mais nenhum arquivo.\r\n * @param {HTMLDivElement} fileItemElement - Elemento do DOM que representa o arquivo na lista.\r\n * @param {File} file - Arquivo a ser removido.\r\n * @param {File[]} uploadedFiles - Lista de arquivos armazenados.\r\n * @param {HTMLButtonElement} confirmButton - Botão de confirmação de upload.\r\n */\r\nfunction removeUploadedFile(fileItemElement, file, uploadedFiles, confirmButton) {\r\n    fileItemElement.remove();\r\n\r\n    const fileIndex = uploadedFiles.indexOf(file);\r\n    if (fileIndex !== -1) {\r\n        uploadedFiles.splice(fileIndex, 1);\r\n    }\r\n\r\n    if (uploadedFiles.length === 0) {\r\n        confirmButton.style.display = 'none';\r\n    }\r\n}\r\n\r\n/**\r\n * Adiciona um arquivo ao mapa de acordo com sua extensão (JSON, GEOJSON, KML ou GPX).\r\n * @param {File} file - Arquivo a ser adicionado ao mapa.\r\n * @param {L.Map} map - Instância do Leaflet Map.\r\n * @param {L.Control.Layer} [layerControl] - Controle de camadas (opcional).\r\n */\r\nfunction renderFileOnMap(file, map, layerControl) {\r\n    const fileExtension = extractFileExtension(file.name);\r\n    const reader = new FileReader();\r\n\r\n    reader.onload = event => {\r\n        try {\r\n            const content = event.target.result;\r\n            const layer = createLayerFromContent(content, fileExtension);\r\n\r\n            if (!layer) {\r\n                throw new Error('Falha ao criar camada a partir do arquivo.');\r\n            }\r\n            addLayerToMap(layer, map, file, layerControl);\r\n\r\n        } catch (error) {\r\n            console.error(`Erro ao processar arquivo ${file.name}:`, error);\r\n            alert(`Erro ao processar arquivo ${file.name}. Verifique o console para mais detalhes.`);\r\n        }\r\n    };\r\n\r\n    reader.readAsText(file);\r\n}\r\n\r\n// Funções auxiliares para manipulação de arquivos\r\nconst getFileNameParts = (fileName) => {\r\n    const lastDotIndex = fileName.lastIndexOf('.');\r\n    return {\r\n        name: fileName.substring(0, lastDotIndex),\r\n        extension: fileName.substring(lastDotIndex + 1).toLowerCase()\r\n    };\r\n};\r\n\r\nconst createLayerNameHTML = (fileName) => {\r\n    const { name, extension } = getFileNameParts(fileName);\r\n    const iconFile = FILE_TYPE_ICONS[extension] || FILE_TYPE_ICONS.default;\r\n    \r\n    return `\r\n        <span class=\"layer-name\">\r\n            <img src=\"${ICON_BASE_PATH}${iconFile}\" \r\n                 alt=\"${extension}\" \r\n                 class=\"layer-icon\"\r\n                 title=\"Tipo de arquivo: ${extension}\">\r\n            ${name}\r\n        </span>\r\n    `;\r\n};\r\n\r\nfunction extractFileExtension(fileName) {\r\n    return fileName.split('.').pop().toLowerCase();\r\n}\r\n\r\nfunction createLayerFromContent(content, extension) {\r\n    switch (extension) {\r\n        case 'json':\r\n        case 'geojson': {\r\n            const geoData = JSON.parse(content);\r\n            return L.geoJSON(geoData);\r\n        }\r\n        case 'kml': {\r\n            const parser = new DOMParser();\r\n            const xmlDoc = parser.parseFromString(content, 'text/xml');\r\n            if (xmlDoc.getElementsByTagName('parsererror').length > 0) {\r\n                throw new Error('KML inválido ou mal formatado');\r\n            }\r\n            return omnivore.kml.parse(content);\r\n        }\r\n        case 'gpx':\r\n            return new L.GPX(content);\r\n        default:\r\n            throw new Error(`Formato de arquivo não suportado: ${extension}`);\r\n    }\r\n}\r\n\r\nfunction addLayerToMap(layer, map, file, layerControl) {\r\n    layer.addTo(map);\r\n\r\n    layer.on('ready', function() {\r\n        this.getBounds && map.fitBounds(this.getBounds());\r\n    });\r\n\r\n    if (layerControl) {\r\n        const layerNameHTML = createLayerNameHTML(file.name);\r\n        layerControl.addOverlay(layer, layerNameHTML);\r\n    }\r\n}\n\n//# sourceURL=webpack://ana_map/./src/components/fileHandler.js?");

/***/ }),

/***/ "./src/components/geocoding.js":
/*!*************************************!*\
  !*** ./src/components/geocoding.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupGeocoding: () => (/* binding */ setupGeocoding)\n/* harmony export */ });\n/**\r\n * @file src\\components\\geocoding.js\r\n * @description Módulo para funcionalidades de geocodificação\r\n * \r\n * Este módulo implementa:\r\n * - Geocodificação reversa usando OpenCage API\r\n * - Exibição de informações detalhadas de localização\r\n * - Manipulação de eventos de clique no mapa\r\n * - Configuração do serviço de geocodificação\r\n * \r\n * @requires leaflet                          \r\n * Sistema de mapas\r\n * @requires leaflet-control-geocoder        \r\n * Controle de geocodificação\r\n */\r\n\r\n\r\n/**\r\n * Cache para armazenar resultados de geocodificação\r\n */\r\nconst cache = {};\r\n\r\n/**\r\n * Conjunto para armazenar coordenadas de marcadores existentes\r\n */\r\nconst existingMarkers = new Set();\r\n\r\n/**\r\n * Função de debounce para limitar a frequência de chamadas\r\n * @param {Function} func - Função a ser debounced\r\n * @param {number} delay - Tempo de espera em milissegundos\r\n * @returns {Function} - Função debounced\r\n */\r\nconst debounce = (func, delay) => {\r\n    let timeout;\r\n    return (...args) => {\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(() => func.apply(undefined, args), delay);\r\n    };\r\n};\r\n\r\n/**\r\n * Busca e exibe informações detalhadas de uma localização\r\n * @param {Object} latlng - Coordenadas do ponto selecionado\r\n * @param {Object} marker - Instância do marcador Leaflet\r\n * @param {number} retryCount - Contador de tentativas (usado internamente para evitar loops infinitos)\r\n * @returns {Promise<string>} Conteúdo formatado do popup\r\n */\r\nasync function exibirInformacoesLocal(latlng, marker, retryCount = 0) {\r\n    const key = `${latlng.lat},${latlng.lng}`;\r\n    if (cache[key]) return cache[key];\r\n\r\n    let content = '';\r\n\r\n    try {\r\n        const response = await fetch(`http://localhost:3000/api/geocode?lat=${latlng.lat}&lng=${latlng.lng}`);\r\n\r\n        if (response.status === 429) {\r\n            const errorData = await response.json();\r\n            const error = new Error(errorData.error.message);\r\n            error.code = errorData.error.code;\r\n            error.retryAfter = errorData.error.retryAfter;\r\n            throw error;\r\n        }\r\n\r\n        if (!response.ok) throw new Error(`Request error: ${response.status}`);\r\n\r\n        const data = await response.json();\r\n\r\n        if (data.results?.[0]) {\r\n            const info = data.results[0];\r\n            const components = info.components;\r\n\r\n            const {\r\n                \"ISO_3166-2\": stateISO = \"n/a\",\r\n                city = components.town || components.village || components.county || \"Not specified\",\r\n                road = components.road || components.highway || components.footway || \"Not specified\",\r\n                postcode = components.postcode || components.postal_code || \"Not available\",\r\n                country = components.country || \"Not available\"\r\n            } = components;\r\n\r\n            const { lat, lng } = info.geometry || { lat: \"n/a\", lng: \"n/a\" };\r\n\r\n            content = `\r\n                <div class=\"geocoding-popup\">\r\n                    <div class=\"geocoding-info-grid\">\r\n                        <div class=\"geocoding-data-item\">\r\n                            <span class=\"geocoding-data-label\">ISO 3166-2</span>\r\n                            <span class=\"geocoding-data-value\">${stateISO}</span>\r\n                        </div>\r\n                        \r\n                        <div class=\"geocoding-data-item\">\r\n                            <span class=\"geocoding-data-label\">Cidade</span>\r\n                            <span class=\"geocoding-data-value\">${city}</span>\r\n                        </div>\r\n\r\n                        <div class=\"geocoding-data-item\">\r\n                            <span class=\"geocoding-data-label\">Rua</span>\r\n                            <span class=\"geocoding-data-value\">${road}</span>\r\n                        </div>\r\n\r\n                        <div class=\"geocoding-data-item\">\r\n                            <span class=\"geocoding-data-label\">CEP</span>\r\n                            <span class=\"geocoding-data-value\">${postcode}</span>\r\n                        </div>\r\n\r\n                        <!-- Coordenadas posicionadas na segunda coluna -->\r\n                        <div class=\"geocoding-data-item\">\r\n                            <span class=\"geocoding-data-label\">Latitude</span>\r\n                            <span class=\"geocoding-data-value\">${lat.toFixed(5)}</span>\r\n                        </div>\r\n\r\n                        <div class=\"geocoding-data-item\">\r\n                            <span class=\"geocoding-data-label\">Longitude</span>\r\n                            <span class=\"geocoding-data-value\">${lng.toFixed(5)}</span>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            `;\r\n        } else {\r\n            content = `\r\n                <div class=\"geocoding-popup\">\r\n                    <div class=\"geocoding-no-data\">\r\n                        Nenhum detalhe disponível para esta localização\r\n                    </div>\r\n            `;\r\n        }\r\n    } catch (error) {\r\n        console.error('❌ Erro ao buscar informações:', error);\r\n        let errorMessage;\r\n\r\n        if (error.code === 'TOO_MANY_REQUESTS') {\r\n            if (retryCount < 5) {\r\n                console.warn(`🔄 Tentativa ${retryCount + 1}: Limite de requisições atingido`);\r\n\r\n                if (marker && marker.getPopup()) {\r\n                    marker.getPopup().setContent(`\r\n                        <div class=\"geocoding-popup\">\r\n                            <div class=\"geocoding-loading\">\r\n                                Aguarde... (Tentativa ${retryCount + 1}/5)\r\n                            </div>\r\n                        </div>\r\n                    `);\r\n                }\r\n\r\n                await new Promise(resolve => setTimeout(resolve, 1000));\r\n                return exibirInformacoesLocal(latlng, marker, retryCount + 1);\r\n            } else {\r\n                errorMessage = \"Erro após várias tentativas. Tente novamente mais tarde.\";\r\n            }\r\n        } else if (error.code === 'DAILY_QUOTA_EXCEEDED') {\r\n            errorMessage = \"Cota diária esgotada! Tente novamente em 24 horas.\";\r\n        } else {\r\n            errorMessage = 'Problema ao carregar dados.';\r\n        }\r\n\r\n        content = `\r\n            <div class=\"geocoding-popup\">\r\n                <div class=\"geocoding-error\">\r\n                    <strong>⚠️ Erro:</strong> ${errorMessage}\r\n                </div>\r\n        `;\r\n    }\r\n\r\n    content += `\r\n            <button class=\"geocoding-remove-btn\">Remover Marcador</button>\r\n        </div>\r\n    `;\r\n\r\n    cache[key] = content;\r\n    return content;\r\n}\r\n\r\n/**\r\n * Configura o componente de geocodificação e eventos relacionados.\r\n * @param {Object} map - Instância do mapa Leaflet.\r\n */\r\nfunction setupGeocoding(map) {\r\n    const popup = L.popup();\r\n\r\n    /**\r\n     * Adiciona um marcador removível ao mapa.\r\n     * @param {Object} latlng - Coordenadas do ponto selecionado.\r\n     */\r\n    const addRemovableMarker = async (latlng) => {\r\n        const key = `${latlng.lat},${latlng.lng}`;\r\n\r\n        // Verifica se já existe um marcador nesse ponto\r\n        if (existingMarkers.has(key)) {\r\n            return; // Não adiciona um novo marcador se já existir\r\n        }\r\n\r\n        // Cria o marcador e adiciona ao mapa\r\n        const marker = L.marker(latlng).addTo(map);\r\n        existingMarkers.add(key); // Adiciona ao conjunto de marcadores existentes\r\n\r\n        // Configura o popup com um estado inicial de \"Carregando...\"\r\n        marker.bindPopup('Carregando...', {\r\n            autoClose: false,\r\n            closeOnClick: false\r\n        }).openPopup();\r\n\r\n        // Busca as informações da localização e atualiza o popup\r\n        const content = await exibirInformacoesLocal(latlng, marker); // Passa o marker aqui\r\n        marker.getPopup().setContent(content);\r\n\r\n        // Adiciona um listener para o botão \"Remove Marker\"\r\n        const popupElement = marker.getPopup().getElement();\r\n        if (popupElement) {\r\n            const removeMarkerHandler = (e) => {\r\n                if (e.target.classList.contains('geocoding-remove-btn')) {\r\n                    map.removeLayer(marker);\r\n                    existingMarkers.delete(key); // Remove do conjunto ao excluir o marcador\r\n                    delete cache[key]; // Limpa o cache para essa coordenada\r\n                    popupElement.removeEventListener('click', removeMarkerHandler); // Remove o listener\r\n                }\r\n            };\r\n            popupElement.addEventListener('click', removeMarkerHandler);\r\n        }\r\n    };\r\n\r\n    // Configura o geocoder\r\n    const geocoder = L.Control.geocoder({\r\n        defaultMarkGeocode: false,\r\n        position: 'topleft',\r\n        placeholder: 'Buscar endereço...', // Placeholder para o campo de busca\r\n        errorMessage: 'Endereço não encontrado.', // Mensagem de erro personalizada\r\n    }).addTo(map);\r\n\r\n    // Evento de geocodificação\r\n    geocoder.on('markgeocode', (e) => {\r\n        const latlng = e.geocode.center;\r\n        map.setView(latlng, 9); // Centraliza o mapa no local encontrado\r\n        addRemovableMarker(latlng); // Adiciona um marcador removível\r\n    });\r\n\r\n    // Evento de clique no mapa com debounce\r\n    const debouncedAddMarker = debounce((e) => addRemovableMarker(e.latlng), 300);\r\n    map.on('click', debouncedAddMarker);\r\n}\n\n//# sourceURL=webpack://ana_map/./src/components/geocoding.js?");

/***/ }),

/***/ "./src/components/importControl.js":
/*!*****************************************!*\
  !*** ./src/components/importControl.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupImportControl: () => (/* binding */ setupImportControl)\n/* harmony export */ });\n/* harmony import */ var _fileHandler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fileHandler.js */ \"./src/components/fileHandler.js\");\n\r\n\r\nfunction setupImportControl(map, layerControl) {\r\n    const ImportControl = L.Control.extend({\r\n        options: { position: 'topleft' },\r\n\r\n        onAdd: function () {\r\n            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');\r\n            const button = L.DomUtil.create('a', '', container);\r\n\r\n            button.innerHTML = '<i class=\"fa-solid fa-upload\"></i>';\r\n            button.href = '#';\r\n            button.role = 'button';\r\n            button.setAttribute('aria-label', 'Importar arquivo');\r\n\r\n            // Evento de clique para exibir o modal\r\n            L.DomEvent.on(button, 'click', (e) => {\r\n                L.DomEvent.preventDefault(e);\r\n                showModal();\r\n            });\r\n\r\n            L.DomEvent.disableClickPropagation(container);\r\n\r\n            return container;\r\n        }\r\n    });\r\n\r\n    // Variável de controle para não duplicar event listeners\r\n    let isModalInitialized = false;\r\n\r\n    function showModal() {\r\n        const modal = document.getElementById('importModal');\r\n        const dropArea = document.getElementById('dropArea');\r\n        const fileInput = document.getElementById('fileInput');\r\n        const fileSelectButton = document.getElementById('fileSelectButton');\r\n        const confirmButton = document.getElementById('confirmUploadButton');\r\n        const fileList = document.getElementById('fileList');\r\n        const closeModalBtn = document.getElementById('closeModal');\r\n\r\n        // Array que armazena os arquivos carregados\r\n        let uploadedFiles = [];\r\n\r\n        modal.style.display = 'block'; // Exibe o modal\r\n\r\n        // Inicializa os listeners apenas na primeira vez que o modal é aberto\r\n        if (!isModalInitialized) {\r\n            attachModalListeners();\r\n            isModalInitialized = true;\r\n        }\r\n\r\n        function attachModalListeners() {\r\n            // Drag-and-drop\r\n            dropArea.addEventListener('dragover', handleDragOver);\r\n            dropArea.addEventListener('dragleave', handleDragLeave);\r\n            dropArea.addEventListener('drop', handleDrop);\r\n\r\n            // Botão \"selecionar arquivo\" e input\r\n            fileSelectButton.addEventListener('click', handleFileSelectClick);\r\n            fileInput.addEventListener('change', handleFileChange);\r\n\r\n            // Botão \"OK\"\r\n            confirmButton.addEventListener('click', handleConfirmUpload);\r\n\r\n            // Botão \"X\" para fechar\r\n            closeModalBtn.onclick = handleCloseModal;\r\n        }\r\n\r\n        /** Drag Over */\r\n        function handleDragOver(e) {\r\n            e.preventDefault();\r\n            dropArea.classList.add('dragover');\r\n        }\r\n\r\n        /** Drag Leave */\r\n        function handleDragLeave() {\r\n            dropArea.classList.remove('dragover');\r\n        }\r\n\r\n        /** Drop */\r\n        function handleDrop(e) {\r\n            e.preventDefault();\r\n            dropArea.classList.remove('dragover');\r\n            (0,_fileHandler_js__WEBPACK_IMPORTED_MODULE_0__.importFiles)({\r\n                files: e.dataTransfer.files,\r\n                fileListElement: fileList,\r\n                confirmButton,\r\n                uploadedFiles,\r\n                skipDuplicates: true // Evita duplicação\r\n            });\r\n        }\r\n\r\n        /** Botão para abrir a janela de seleção de arquivos */\r\n        function handleFileSelectClick() {\r\n            fileInput.click();\r\n        }\r\n\r\n        /** Quando o usuário seleciona arquivos pelo input */\r\n        function handleFileChange(e) {\r\n            (0,_fileHandler_js__WEBPACK_IMPORTED_MODULE_0__.importFiles)({\r\n                files: e.target.files,\r\n                fileListElement: fileList,\r\n                confirmButton,\r\n                uploadedFiles,\r\n                skipDuplicates: true\r\n            });\r\n        }\r\n\r\n        /** Botão \"OK\": adiciona os arquivos ao mapa */\r\n        function handleConfirmUpload() {\r\n            uploadedFiles.forEach(file => {\r\n                (0,_fileHandler_js__WEBPACK_IMPORTED_MODULE_0__.renderFileOnMap)(file, map, layerControl);\r\n            });\r\n\r\n            // Limpa a lista de arquivos após o upload\r\n            fileList.innerHTML = '';\r\n            uploadedFiles = [];\r\n            confirmButton.style.display = 'none';\r\n            modal.style.display = 'none';\r\n        }\r\n\r\n        /** Fechar modal */\r\n        function handleCloseModal() {\r\n            modal.style.display = 'none';\r\n        }\r\n    }\r\n\r\n    // Instancia e adiciona o controle personalizado ao mapa\r\n    const control = new ImportControl();\r\n    control.addTo(map);\r\n}\r\n\n\n//# sourceURL=webpack://ana_map/./src/components/importControl.js?");

/***/ }),

/***/ "./src/components/layerControl.js":
/*!****************************************!*\
  !*** ./src/components/layerControl.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addLayerControl: () => (/* binding */ addLayerControl)\n/* harmony export */ });\n/**\r\n * @file src\\components\\layerControl.js\r\n * @description Controlador de camadas do mapa com padrões Clean Code\r\n */\r\n\r\n\r\n// Constantes para melhor manutenção e legibilidade\r\nconst LAYER_CONTROL_POSITION = 'topleft';\r\nconst DEFAULT_LAYER_NAME = 'Satélite com Rótulos';\r\n\r\nconst BASE_LAYERS_CONFIG = {\r\n    'OpenStreetMap': {\r\n        url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\r\n        attribution: '© OpenStreetMap'\r\n    },\r\n    'OpenTopoMap': {\r\n        url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',\r\n        attribution: '© OpenTopoMap'\r\n    },\r\n    'CartoDB Positron': {\r\n        url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',\r\n        attribution: '© CartoDB'\r\n    },\r\n    'OSM Humanitarian': {\r\n        url: 'https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png',\r\n        attribution: '© OpenStreetMap contributors, Tiles style by Humanitarian OpenStreetMap Team'\r\n    },\r\n    'CartoDB Voyager': {\r\n        url: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',\r\n        attribution: '© OpenStreetMap contributors, © CartoDB'\r\n    },\r\n    'Stadia Maps - Stamen Toner': {\r\n        url: 'https://tiles.stadiamaps.com/tiles/stamen_toner/{z}/{x}/{y}{r}.png',\r\n        attribution: 'Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under ODbL.'\r\n    },\r\n    'Esri WorldStreetMap': {\r\n        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',\r\n        attribution: 'Tiles © Esri'\r\n    },\r\n    'Stadia Maps - OSM Bright': {\r\n        url: 'https://tiles.stadiamaps.com/tiles/osm_bright/{z}/{x}/{y}{r}.png',\r\n        attribution: '© OpenStreetMap contributors, © Stadia Maps'\r\n    },\r\n    'Stadia Maps - Stamen Terrain': {\r\n        url: 'https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}{r}.png',\r\n        attribution: 'Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under ODbL.'\r\n    }\r\n};\r\n\r\nconst ESRI_LAYERS_CONFIG = {\r\n    base: {\r\n        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\r\n        attribution: '© Esri'\r\n    },\r\n    labels: {\r\n        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}',\r\n        options: { opacity: 0.8 }\r\n    },\r\n    reference: {\r\n        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',\r\n        options: { opacity: 0.95 }\r\n    }\r\n};\r\n\r\n// Funções utilitárias\r\nconst createTileLayer = (url, attribution = '', options = {}) =>\r\n    L.tileLayer(url, { attribution, ...options });\r\n\r\nconst createLayerGroup = layers => L.layerGroup(layers);\r\n\r\n// Fábrica de camadas\r\nconst createBaseLayers = () => {\r\n    const layers = {};\r\n    for (const [name, config] of Object.entries(BASE_LAYERS_CONFIG)) {\r\n        layers[name] = createTileLayer(config.url, config.attribution);\r\n    }\r\n    return layers;\r\n};\r\n\r\nconst createEsriLayers = () => {\r\n    const layers = {\r\n        base: createTileLayer(ESRI_LAYERS_CONFIG.base.url, ESRI_LAYERS_CONFIG.base.attribution),\r\n        labels: createTileLayer(ESRI_LAYERS_CONFIG.labels.url, '', ESRI_LAYERS_CONFIG.labels.options),\r\n        reference: createTileLayer(ESRI_LAYERS_CONFIG.reference.url, '', ESRI_LAYERS_CONFIG.reference.options)\r\n    };\r\n    return createLayerGroup([layers.base, layers.labels, layers.reference]);\r\n};\r\n\r\n// Controle de camadas\r\nconst setupLayerControl = (map, baseLayers, position) => {\r\n    const control = L.control.layers(baseLayers, null, { position });\r\n    control.addTo(map);\r\n    return control;\r\n};\r\n\r\n// Função principal\r\nconst addLayerControl = (map) => {\r\n    const baseLayers = createBaseLayers();\r\n    const satelliteLayer = createEsriLayers();\r\n\r\n    baseLayers[DEFAULT_LAYER_NAME] = satelliteLayer;\r\n\r\n    const layerControl = setupLayerControl(map, baseLayers, LAYER_CONTROL_POSITION);\r\n    satelliteLayer.addTo(map);\r\n\r\n    return layerControl;\r\n};\n\n//# sourceURL=webpack://ana_map/./src/components/layerControl.js?");

/***/ }),

/***/ "./src/components/mapControl.js":
/*!**************************************!*\
  !*** ./src/components/mapControl.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupMapControls: () => (/* binding */ setupMapControls)\n/* harmony export */ });\n// file: src\\components\\mapControl.js\r\n\r\n// Constantes para valores mágicos\r\nconst ZOOM_SENSITIVITY = {\r\n  MIN: 60,\r\n  MAX: 2000,\r\n  DEFAULT: 250\r\n};\r\n\r\nconst CONTROL_CLASSES = {\r\n  CONTAINER: 'custom-map-control leaflet-bar',\r\n  HEADER: 'control-header',\r\n  PANEL_DESCRIPTION: 'panel-description',\r\n  EXPANDED_PANEL: 'expanded-panel',\r\n  ZOOM_SECTION: 'zoom-sensitivity-section',\r\n  DRAG_SECTION: 'drag-toggle-section'\r\n};\r\n\r\n/**\r\n * Configura controles personalizados do mapa seguindo princípios de Clean Code\r\n * @param {Object} map - Instância do mapa Leaflet\r\n */\r\nfunction setupMapControls(map) {\r\n  configureMapDefaults(map);\r\n  addCustomControlPanel(map);\r\n  addStandardControls(map);\r\n}\r\n\r\nfunction configureMapDefaults(map) {\r\n  map.options.wheelPxPerZoomLevel = ZOOM_SENSITIVITY.DEFAULT;\r\n}\r\n\r\nfunction addStandardControls(map) {\r\n  addScaleControl(map);\r\n  addFullscreenControl(map);\r\n}\r\n\r\nfunction createControlContainer() {\r\n  const container = L.DomUtil.create('div', CONTROL_CLASSES.CONTAINER);\r\n  container.innerHTML = `\r\n      <div class=\"${CONTROL_CLASSES.HEADER}\">\r\n        <a href=\"#\" class=\"toggle-panel\" title=\"Configurações do mapa\" role=\"button\" aria-label=\"Configurações do mapa\">\r\n          <i class=\"fa fa-cog\"></i>\r\n        </a>\r\n        <div class=\"${CONTROL_CLASSES.PANEL_DESCRIPTION}\">Controles do mapa</div>\r\n      </div>\r\n      \r\n      <div class=\"${CONTROL_CLASSES.EXPANDED_PANEL}\">\r\n        <div class=\"${CONTROL_CLASSES.ZOOM_SECTION}\">\r\n          <label for=\"zoomSensitivity\">\r\n            <span title=\"Ajuste de sensibilidade do zoom\">\r\n              <img src=\"/assets/zoom_sensibility.png\" alt=\"Zoom Icon\"/>\r\n            </span>\r\n          </label>\r\n          <input id=\"zoomSensitivity\" type=\"range\" min=\"${ZOOM_SENSITIVITY.MIN}\" max=\"${ZOOM_SENSITIVITY.MAX}\"/>\r\n          <span class=\"value\">${ZOOM_SENSITIVITY.DEFAULT}</span>\r\n        </div>\r\n  \r\n        <div class=\"${CONTROL_CLASSES.DRAG_SECTION}\">\r\n          <i class=\"fa fa-hand-paper\" title=\"Habilitar ou desabilitar o arrasto do mapa\"></i>\r\n          <label class=\"switch\">\r\n            <input type=\"checkbox\" id=\"dragSwitch\" checked />\r\n            <span class=\"slider round\"></span>\r\n          </label>\r\n        </div>\r\n      </div>\r\n    `;\r\n\r\n  L.DomEvent.disableClickPropagation(container);\r\n  return container;\r\n}\r\n\r\nfunction setupControlInteractions(container, map) {\r\n  const elements = {\r\n    toggleBtn: container.querySelector('.toggle-panel'),\r\n    expandedPanel: container.querySelector(`.${CONTROL_CLASSES.EXPANDED_PANEL}`),\r\n    panelDescription: container.querySelector(`.${CONTROL_CLASSES.PANEL_DESCRIPTION}`),\r\n    zoomInput: container.querySelector('#zoomSensitivity'),\r\n    valueSpan: container.querySelector('.value'),\r\n    dragCheckbox: container.querySelector('#dragSwitch')\r\n  };\r\n\r\n  setupToggleLogic(elements);\r\n  setupZoomSensitivity(elements, map);\r\n  setupDragToggle(elements, map);\r\n}\r\n\r\nfunction setupToggleLogic({ toggleBtn, expandedPanel, panelDescription }) {\r\n  toggleBtn.onclick = () => {\r\n    const isVisible = expandedPanel.style.display === 'block';\r\n    expandedPanel.style.display = isVisible ? 'none' : 'block';\r\n    panelDescription.style.display = isVisible ? 'none' : 'block';\r\n    return false;\r\n  };\r\n}\r\n\r\nfunction setupZoomSensitivity({ zoomInput, valueSpan }, map) {\r\n  zoomInput.value = map.options.wheelPxPerZoomLevel;\r\n  valueSpan.textContent = map.options.wheelPxPerZoomLevel;\r\n\r\n  zoomInput.onchange = ({ target }) => {\r\n    map.options.wheelPxPerZoomLevel = Number(target.value);\r\n    valueSpan.textContent = target.value;\r\n  };\r\n}\r\n\r\nfunction setupDragToggle({ dragCheckbox }, map) {\r\n  dragCheckbox.onchange = ({ target }) => {\r\n    target.checked ? map.dragging.enable() : map.dragging.disable();\r\n  };\r\n}\r\n\r\nfunction addCustomControlPanel(map) {\r\n  const customControl = L.control({ position: 'topleft' });\r\n\r\n  customControl.onAdd = () => {\r\n    const container = createControlContainer();\r\n    setupControlInteractions(container, map);\r\n    return container;\r\n  };\r\n\r\n  customControl.addTo(map);\r\n}\r\n\r\nfunction addScaleControl(map) {\r\n  L.control.scale({\r\n    position: 'bottomleft',\r\n    metric: true,\r\n    imperial: false,\r\n    maxWidth: 90,\r\n    updateWhenIdle: false\r\n  }).addTo(map);\r\n}\r\n\r\nfunction addFullscreenControl(map) {\r\n  const fullscreenControl = L.control.fullscreen({\r\n    position: 'topright',\r\n    title: 'Ver em tela cheia',\r\n    titleCancel: 'Sair de tela cheia',\r\n    forceSeparateButton: true,\r\n    pseudoFullscreen: false,\r\n    content: '<i class=\"fa fa-expand\"></i>' // Ícone inicial\r\n  }).addTo(map);\r\n\r\n  // Quando o mapa entrar em tela cheia, altere o ícone para \"compress\" (sair da tela cheia)\r\n  map.on('enterFullscreen', function () {\r\n    const button = fullscreenControl.getContainer().querySelector('a');\r\n    if (button) {\r\n      button.innerHTML = '<i class=\"fa fa-compress\"></i>';\r\n    }\r\n  });\r\n\r\n  // Quando o mapa sair do modo tela cheia, altere o ícone para \"expand\" (entrar em tela cheia)\r\n  map.on('exitFullscreen', function () {\r\n    const button = fullscreenControl.getContainer().querySelector('a');\r\n    if (button) {\r\n      button.innerHTML = '<i class=\"fa fa-expand\"></i>';\r\n    }\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://ana_map/./src/components/mapControl.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_geocoding_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/geocoding.js */ \"./src/components/geocoding.js\");\n/* harmony import */ var _components_mapControl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/mapControl.js */ \"./src/components/mapControl.js\");\n/* harmony import */ var _components_importControl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/importControl.js */ \"./src/components/importControl.js\");\n/* harmony import */ var _components_layerControl_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/layerControl.js */ \"./src/components/layerControl.js\");\n/* harmony import */ var _components_ana_stationsMarkers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/ana/stationsMarkers.js */ \"./src/components/ana/stationsMarkers.js\");\n/* harmony import */ var _utils_notifications_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/notifications.js */ \"./src/utils/notifications.js\");\n/* harmony import */ var _components_Hydro_Estimator_Rainfall_HourlyRainfall_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/Hydro_Estimator_Rainfall/HourlyRainfall.js */ \"./src/components/Hydro_Estimator_Rainfall/HourlyRainfall.js\");\n/**\r\n * @file src\\main.js\r\n * @description Módulo principal para inicialização e configuração do mapa Leaflet.\r\n * @module MainMap\r\n * \r\n * @license MIT\r\n * @copyright 2024 Sistema de Monitoramento Hidrometeorológico\r\n * \r\n * @summary Implementa a configuração central do mapa e integração de componentes:\r\n *  - Inicialização do mapa base com parâmetros geográficos específicos\r\n *  - Gerenciamento de camadas e controles interativos\r\n *  - Integração de serviços de geocodificação\r\n *  - Carregamento dinâmico de marcadores\r\n *  - Tratamento centralizado de erros\r\n * \r\n * @example\r\n * // Estrutura HTML requerida\r\n * <div id=\"map\" style=\"height: 100vh; width: 100%\"></div>\r\n * \r\n * @see {@link https://leafletjs.com/|Leaflet.js Documentation}\r\n * \r\n * @requires {@link module:leaflet} Dependência principal para renderização do mapa\r\n * @requires {@link module:components/layerControl} Controle de camadas dinâmicas\r\n * @requires {@link module:components/geocoding} Serviço de geocodificação integrado\r\n * @requires {@link module:components/mapControl} Controles customizados do mapa\r\n * @requires {@link module:utils/notifications} Sistema de notificação de erros\r\n * @requires {@link module:components/ana/stationsMarkers} Dados das estações monitoradas\r\n * \r\n * @throws {ReferenceError} Se o elemento HTML #map não for encontrado\r\n * @throws {TypeError} Se a biblioteca Leaflet não estiver carregada\r\n * \r\n * @property {L.Map} map Instância principal do mapa Leaflet\r\n * @property {L.Control.Layers} layerControl Referência do controle de camadas\r\n */\r\n\r\n/**\r\n * Configuração geográfica inicial:\r\n * - Centro do mapa: Coordenadas de Mato Grosso (-12.6819, -56.9211)\r\n * - Zoom inicial: Nível 6 (visualização estadual)\r\n * - Limites de navegação: [-85, -180] a [85, 180] (prevenção de pan excessivo)\r\n * - Comportamento do zoom: Suave com snap de 0.3 e delta de 0.6\r\n * \r\n * @constant {Object} mapConfig\r\n * @property {number[]} center Coordenadas [lat, lng] do centro inicial\r\n * @property {number} zoom Nível de zoom inicial (0-18)\r\n * @property {number} minZoom Zoom mínimo permitido\r\n * @property {number} maxZoom Zoom máximo permitido\r\n * @property {number[][]} maxBounds Limites máximos de navegação\r\n * @property {number} maxBoundsViscosity Resistência ao arraste além dos limites\r\n */\r\n\r\n// Importa módulos necessários para funcionalidades do mapa\r\n\r\n\r\n\r\n\r\n\r\n // <-- Adicione esta linha\r\n\r\n\r\n/**\r\n * Configuração geográfica do mapa.\r\n * @constant {Object} mapConfig\r\n */\r\nconst mapConfig = {\r\n    center: [-12.6819, -56.9211],  // Coordenadas de Mato Grosso\r\n    zoom: 6,                       // Nível de zoom inicial\r\n    minZoom: 2,                    // Limite mínimo de zoom\r\n    maxZoom: 18,                   // Limite máximo de zoom\r\n    zoomControl: true,             // Habilita controles de zoom\r\n    zoomSnap: 0.3,                 // Permite zoom mais suave\r\n    zoomDelta: 0.6,                // Controla incremento do zoom por clique\r\n    maxBounds: [                   // Limites máximos do mapa\r\n        [-89.9999, -179.9999],  // Canto sudoeste extremo (próximo ao Polo Sul)\r\n        [89.9999, 179.9999]     // Canto nordeste extremo (próximo ao Polo Norte)\r\n    ],\r\n    maxBoundsViscosity: 1.0        // Resistência ao arraste além dos limites\r\n};\r\n\r\n// Verifica se o elemento do mapa existe antes de inicializar\r\nconst mapElement = document.getElementById('map');\r\nif (!mapElement) {\r\n    const errorMessage = 'Elemento do mapa não encontrado. Verifique se o ID \"map\" está correto.';\r\n    console.error(errorMessage);\r\n    (0,_utils_notifications_js__WEBPACK_IMPORTED_MODULE_5__.showError)(errorMessage);\r\n} else {\r\n    try {\r\n        // Verifica se o Leaflet.js está carregado\r\n        if (typeof L === 'undefined') {\r\n            throw new TypeError('Leaflet.js não está carregado. Verifique se a biblioteca foi importada corretamente.');\r\n        }\r\n\r\n        /// Cria e configura a instância principal do mapa\r\n        const map = L.map('map', mapConfig); // <-- Usa a constante config\r\n\r\n        // Adicionar validação de tipo para o objeto map\r\n        if (!(map instanceof L.Map)) {\r\n            throw new TypeError('Instância do mapa Leaflet inválida');\r\n        }\r\n\r\n        // Inicializa o controle de camadas e armazena sua referência\r\n        const layerControl = (0,_components_layerControl_js__WEBPACK_IMPORTED_MODULE_3__.addLayerControl)(map);\r\n\r\n        // Inicializa os componentes necessários com tratamento de erros\r\n        try {\r\n            (0,_components_geocoding_js__WEBPACK_IMPORTED_MODULE_0__.setupGeocoding)(map);                   // Configura serviço de geocodificação\r\n        } catch (error) {\r\n            console.error('Erro ao configurar geocodificação:', error);\r\n            (0,_utils_notifications_js__WEBPACK_IMPORTED_MODULE_5__.showError)('Falha ao configurar geocodificação. Verifique o console para mais detalhes.');\r\n        }\r\n\r\n        try {\r\n            (0,_components_importControl_js__WEBPACK_IMPORTED_MODULE_2__.setupImportControl)(map, layerControl); // Adiciona controle para importação de arquivos\r\n        } catch (error) {\r\n            console.error('Erro ao configurar controle de importação:', error);\r\n            (0,_utils_notifications_js__WEBPACK_IMPORTED_MODULE_5__.showError)('Falha ao configurar controle de importação. Verifique o console para mais detalhes.');\r\n        }\r\n\r\n        try {\r\n            (0,_components_mapControl_js__WEBPACK_IMPORTED_MODULE_1__.setupMapControls)(map);                 // Configura controles personalizados\r\n        } catch (error) {\r\n            console.error('Erro ao configurar controles do mapa:', error);\r\n            (0,_utils_notifications_js__WEBPACK_IMPORTED_MODULE_5__.showError)('Falha ao configurar controles do mapa. Verifique o console para mais detalhes.');\r\n        }\r\n\r\n        try {\r\n            // Inicializa primeiro o módulo de marcadores\r\n            _components_ana_stationsMarkers_js__WEBPACK_IMPORTED_MODULE_4__.StationMarkers.initialize(map);\r\n            await _components_ana_stationsMarkers_js__WEBPACK_IMPORTED_MODULE_4__.StationMarkers.load();\r\n        } catch (error) {\r\n            console.error('Erro ao carregar marcadores:', error);\r\n            (0,_utils_notifications_js__WEBPACK_IMPORTED_MODULE_5__.showError)('Falha ao carregar marcadores. Verifique o console para mais detalhes.');\r\n        }\r\n\r\n        try {\r\n            // setupHourlyRainfall(map); // Configura camadas de precipitação horária\r\n        } catch (error) {\r\n            console.error('Erro ao configurar camadas de precipitação horária:', error);\r\n            (0,_utils_notifications_js__WEBPACK_IMPORTED_MODULE_5__.showError)('Falha ao configurar camadas de precipitação horária. Verifique o console para mais detalhes.');\r\n        }\r\n\r\n    } catch (error) {\r\n        console.error('Erro ao inicializar o mapa:', error);\r\n        (0,_utils_notifications_js__WEBPACK_IMPORTED_MODULE_5__.showError)('Falha ao inicializar o mapa. Verifique o console para mais detalhes.');\r\n    }\r\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://ana_map/./src/main.js?");

/***/ }),

/***/ "./src/utils/formatTimestamp.js":
/*!**************************************!*\
  !*** ./src/utils/formatTimestamp.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertTimestampToDate: () => (/* binding */ convertTimestampToDate),\n/* harmony export */   formatTimestamp: () => (/* binding */ formatTimestamp)\n/* harmony export */ });\n/**\r\n * @file src/utils/formatTimestamp.js\r\n * @description Utilitários para manipulação de timestamps no formato YYYYMMDD_HHMMSS (UTC).\r\n */\r\n\r\n/**\r\n * Converte um timestamp no formato \"YYYYMMDD_HHMMSS\" para um objeto Date (UTC).\r\n * @param {string} ts - Timestamp no formato \"YYYYMMDD_HHMMSS\" (ex.: \"20231020_123045\").\r\n * @returns {Date} Objeto Date correspondente ao timestamp em UTC.\r\n */\r\nfunction convertTimestampToDate(ts) {\r\n    const datePart = ts.slice(0, 8);   // \"YYYYMMDD\"\r\n    const timePart = ts.slice(9, 15);  // \"HHMMSS\"\r\n    const year = parseInt(datePart.slice(0, 4), 10);\r\n    const month = parseInt(datePart.slice(4, 6), 10) - 1; // meses base 0\r\n    const day = parseInt(datePart.slice(6, 8), 10);\r\n    const hours = parseInt(timePart.slice(0, 2), 10);\r\n    const minutes = parseInt(timePart.slice(2, 4), 10);\r\n    const seconds = parseInt(timePart.slice(4, 6), 10);\r\n    return new Date(Date.UTC(year, month, day, hours, minutes, seconds));\r\n}\r\n\r\n/**\r\n * Formata um timestamp no formato \"YYYYMMDD_HHMMSS\" para \"YYYY-MM-DD HH:MM:SS\" (UTC).\r\n * @param {string} timestamp - Timestamp no formato \"YYYYMMDD_HHMMSS\" (ex.: \"20231020_123045\").\r\n * @returns {string} Data formatada em UTC (ex.: \"2023-10-20 12:30:45\").\r\n */\r\nfunction formatTimestamp(timestamp) {\r\n    const date = convertTimestampToDate(timestamp);\r\n    return date.toISOString().replace('T', ' ').substring(0, 19);\r\n}\n\n//# sourceURL=webpack://ana_map/./src/utils/formatTimestamp.js?");

/***/ }),

/***/ "./src/utils/notifications.js":
/*!************************************!*\
  !*** ./src/utils/notifications.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   showError: () => (/* binding */ showError)\n/* harmony export */ });\n// Função para exibir mensagens de erro visíveis ao usuário\r\nfunction showError(message) {\r\n    const errorDiv = document.createElement('div');\r\n    \r\n    // Configuração do container de erro\r\n    errorDiv.style.cssText = `\r\n        position: fixed;\r\n        top: 10px;\r\n        left: 50%;\r\n        transform: translateX(-50%);\r\n        background: #ffe6e6;\r\n        border: 1px solid red;\r\n        border-radius: 5px;\r\n        padding: 12px 40px 12px 20px;\r\n        color: red;\r\n        z-index: 1000;\r\n        display: flex;\r\n        align-items: center;\r\n        gap: 15px;\r\n        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\r\n        max-width: 80%;\r\n        font-size: 18px;\r\n    `;\r\n\r\n    // Texto da mensagem\r\n    const text = document.createElement('span');\r\n    text.textContent = `Erro: ${message}`;\r\n\r\n    // Ícone de fechar (X)\r\n    const closeIcon = document.createElement('span');\r\n    closeIcon.innerHTML = '&times;'; // Entidade HTML para o X\r\n    closeIcon.style.cssText = `\r\n        cursor: pointer;\r\n        font-size: 25px;\r\n        position: absolute;\r\n        right: 12px;\r\n        top: 50%;\r\n        transform: translateY(-50%);\r\n        line-height: 1;\r\n    `;\r\n\r\n    // Evento para fechar ao clicar no X\r\n    closeIcon.addEventListener('click', () => {\r\n        document.body.removeChild(errorDiv);\r\n    });\r\n\r\n    // Adiciona elementos ao container\r\n    errorDiv.appendChild(text);\r\n    errorDiv.appendChild(closeIcon);\r\n    document.body.appendChild(errorDiv);\r\n\r\n    // Fecha a mensagem ao pressionar Esc (opcional)\r\n    const handleKeyPress = (e) => {\r\n        if (e.key === 'Escape') {\r\n            document.body.removeChild(errorDiv);\r\n            document.removeEventListener('keydown', handleKeyPress);\r\n        }\r\n    };\r\n    document.addEventListener('keydown', handleKeyPress);\r\n}\n\n//# sourceURL=webpack://ana_map/./src/utils/notifications.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && queue.d < 1) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = -1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && queue.d < 0 && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;